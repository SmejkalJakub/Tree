<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: tree.mjs</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: tree.mjs</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/** 
 * @module Tree 
 */

/**
 * @constructor
 * @param {Function} evalFunction - This functions decides 
 * if the new value should be added to the left or right subtree. 
 * It should have 2 parameters and return True/False. 
 * If the function returns True, new value will be added to the left subtree, 
 * otherwise it will be added to the right subtree.
 */
export function Tree(evalFunction) {
    this.evalFunction = evalFunction;

    /**
     * Root node of the created Tree
     * @type {Node}
     */
    this.root = null;
    
    /**
     * This function takes care of inserting new nodes to the tree.
     * If there is no root it will just create it. Otherwise it will start recursion
     * that will insert the node to the tree based on the specified evalFunction.
     * @param {any} value - specified value that the new node should have
     */
    this.insertValue = function(value){
        var node = new Node(value);

        if(this.root === null){
            this.root = node;
        }
        else{
            this.insertNode(this.root, node);
        }   
    }

    /**
     * Inserts new node to the tree. If the node should be inserted to the 
     * left or right subtree is decided on evalFunction.
     * If the selected child is empty, new node is inserted there. 
     * Otherwise this function is recursively called on selected subtree.
     * @param {Node} node - parent node on which the new node should be attached to
     * @param {Node} newNode - new node that should be inserted
     */
    this.insertNode = function(node, newNode){
        if(this.evalFunction(newNode.value, node.value)){
            if(node.left === null){
                node.left = newNode;
            }
            else{
                this.insertNode(node.left, newNode);
            }
        }
        else{
            if(node.right === null){
                node.right = newNode;
            }
            else{
                this.insertNode(node.right, newNode);
            }
        }
    }

    /**
     * Function that creates generator for traversing the tree in preorder manner
     * @returns {Generator} - Generator for traversing the tree in preorder manner
     */
    this.preorder = function(){
        return this.preorder.prototype.next(this.root);
    }

    /**
     * Function that creates generator for traversing the tree in inorder manner
     * @returns {Generator} - Generator for traversing the tree in inorder manner
     */
    this.inorder = function(){
        return this.inorder.prototype.next(this.root);
    }

    /**
     * Function that creates generator for traversing the tree in postorder manner
     * @returns {Generator} - Generator for traversing the tree in postorder manner
     */
    this.postorder = function(){
        return this.postorder.prototype.next(this.root);
    }


    this.preorder.prototype.next = function* (node = this.root){
        if(node !== null){
            yield node.value;
            yield* this.next(node.left);
            yield* this.next(node.right);
        }
    }

    this.inorder.prototype.next = function* (node = this.root){
        if(node !== null){
            yield* this.next(node.left);
            yield node.value;
            yield* this.next(node.right);
        }
    }

    this.postorder.prototype.next = function* (node = this.root){
        if(node !== null){
            yield* this.next(node.left);
            yield* this.next(node.right);
            yield node.value;
        }   
    }
}

/**
 * Representation of the tree node
 * @constructor
 * @param {any} value - value that should be stored in the Node
 */
function Node(value) {
    /**
     * Value of the specific node
     * @type {any}
     */
    this.value = value;
    /**
     * Reference to the left child of the node
     * @type {Node}
     */
    this.left = null;
    /**
     * Reference to the right child of the node
     * @type {Node}
     */
    this.right = null;
  }</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-Tree.html">Tree</a></li></ul><h3>Classes</h3><ul><li><a href="module-Tree.Tree.html">Tree</a></li><li><a href="module-Tree-Node.html">Node</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.10</a> on Thu Feb 17 2022 11:43:19 GMT+0100 (Central European Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
